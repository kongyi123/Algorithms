// 중요한점.
// 배열의 연속된 구간 최대 부분합은 O(N) 만에 해결이 된다.
// 연속된 최대 부분 2차원 영역은?? O(N^2) 만에 되지 않을까? 확장해서 생각해보기.
// 특징을 잡아낸다면 부분합 을 구하는 것이고, 부분합 중에 최대를 구하는 것이니까.


// n만에 부분 최대합 구간을 구하기 위해서는 어떤 규칙을 찾아야 한다.
// 그 규칙은 = 시작 부분이 음수이면 차라리 0부터 시작하는게 낫다. 즉, 음수 합이 되는 부분은 이전까지 누적된 합을 지워버리고
// 처음부터 더해는게 낫다는 것이다.

// 물론 바로 관찰후 개념으로 n만에 최대 구간 부분합을 구할 수 있다는 것을 유도해 내면 좋긴 좋다.
// 그러나 그게 보이지않는다면?

// N^2 에서 N으로 접근할 수 있는 방법이 없을까?

// N^3 -> N^2 할때는 중복되는 개념을 찾아서 제거해주었다.


// 두가지 어프로치가 있겠다.
// 수치의 시각화에 따른 직관적으로 솔루션을 찾거나
// 차원의 제한을 둔 다이나믹 프로그래밍 - 정의를 정해놓고 배열을 채워본다.
// 그 배열에 채워진 값을 어떻게 일반적으로 유도할지를 차원을 달리하면서 고민한다.



#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {
	int n;
	fscanf(stdin, "%d", &n);
	int sum = 0;
	int ans = -2000000000;
	int reset = 1;
	for (int i = 1;i <= n;i++) {
		int data;
		if (reset) sum = 0;
		fscanf(stdin, "%d", &data);
		sum += data;
		if (sum < 0) reset = 1;
		else reset = 0;
		if (sum > ans) ans = sum;
	}
	fprintf(stdout, "%d", ans);
	return 0;
}

